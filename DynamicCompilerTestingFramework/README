#!/bin/bash

# Dynamic Compiler Testing Framework

# This project allows defining JUnit test cases for detecting performance bugs
# in the dynamic compiler. The project relies on the Graal compiler decision 
# API.

# Follow the steps to create a test case
# 1. Create a sub class extending ch.usi.dag.testing.JITTestCase
# 2. Override warmup() and isWarmedUp(). warmup() is for training target 
#    methods, while isWarmedUp() is for determining the compilation status of 
#    the target methods. This is implemented using static query 
#    isMethodCompiled() in the target methods, which can guard a callback that 
#    changes the compilation status. During the warmup phase, warmup() is
#    repeatedly called till isWarmedUp() returns true.
# 3. Create test methods with annotation @Test, which focus on a specific aspect
#    of the dynamic compiler.

# As an example, we create a test case on the partial escape analysis. There are
# three cases where the allocation must be escaping, not-escaping, or 
# partial escaping. PEA will perform stack allocation in the second case, and a 
# hybrid allocation strategy in the third case.

# Same to running a JUnit test case, you may run the folllowing code:
mx vm -Xbootclasspath/a:../lib/graal-external.jar \
    -cp ../lib/junit-4.11.jar:../lib/hamcrest-core-1.3.jar:bin \
    org.junit.runner.JUnitCore \
    pea.PEATestCase \
    pea.MustEscape \
    pea.NotEscape \
    pea.PartialEscape

# A second example is testing inlining in Graal. You may create new scenarios 
# to learn about the inlining strategy in Graal.
mx vm -Xbootclasspath/a:../lib/graal-external.jar \
    -cp ../lib/junit-4.11.jar:../lib/hamcrest-core-1.3.jar:bin \
    org.junit.runner.JUnitCore \
    inlining.InlineSimpleMethod \
    inlining.NotInlineAnnotatedMethod \
    inlining.InlineComplicatedMethod \
    inlining.NotInlineComplicatedMethod
